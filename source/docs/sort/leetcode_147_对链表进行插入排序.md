# leetcode 147. 对链表进行插入排序

## 题目先导

> 排序来排序去，数值虽有序，学习无高低。 —— by 胖胖

| 类型 | 难度 | 相关标签&基础知识 | 题目链接 |
| :------: | :--------: | :---: | :------: | 
| 算法 | 中等 | 数组、[排序](#) | [对链表进行插入排序](#) | 

## 题目描述

```
对链表进行插入排序。

插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。
 
插入排序算法：

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 

示例 1：
输入: 4->2->1->3
输出: 1->2->3->4

示例 2：
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```

## 解题思路
对链表进行插入排序, 题目有介绍插入排序的介绍. 当遍历到第i个元素的时候, 此时链表的前i-1元素都是有序的, 此时需要遍历前i-1个元素的链表, 将第i个元素插入到对应的维度, 以此类推直到链表有序.

```
4->2->1->3
因为链表的插入只能从头向后进行遍历,进行比较, 为了更好的处理头节点的插入, 我们设置一个虚拟的头结点new_head(-1).

原始有序链表: -1

第1次: 4, 是第一个元素, 直接插入得到新有序链表:
-1 -> 4

第2次: 元素2, 从头遍历找到第一个大于2的元素节点k,将它拆入到k之前的位置. 由于4 > 2, 因此将2插入到4之前. 得到新的有序链表:
-1 -> 2 -> 4

第3次: 元素1,  从头遍历找到第一个大于1的元素节点k,将它拆入到k之前的位置. 由于2 > 1, 因此将1插入到2之前. 得到新的有序链表:
-1 -> 1 -> 2 -> 4

第4次: 元素3,  从头遍历找到第一个大于1的元素节点k,将它拆入到k之前的位置. 由于4 > 3, 因此将3插入到4之前. 得到新的有序链表:
-1 -> 1 -> 2 -> 3 -> 4

最后返回排序后的链表, 将-1的下一个节点作为头节点返回.
```

## 难点分析

难点1: 在于如何处理头节点的插入, 一般情况下在链表的题目中, 都存在类似的问题, 我们的解决方法基本都是维护一个新的临时头节点new_head, 最后返回真是的头节点: new_head->next.

难点2: 当我们遍历到第i个节点, 需要将第i个节点插入到前i-1个节点的有序的位置上, 此时我们需要先保存下来第i+1个节点, 作为接下来的遍历使用.


## 代码
- 代码支持：C++、Python

**C++ Code**
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        if (!head) {
            return head;
        }
        ListNode* cur = head;
        ListNode* cur_next = cur_next;
        ListNode* new_head = new ListNode(-1);
        while (cur != nullptr) {
            // cout << cur->val << endl;
            cur_next = cur->next;
            ListNode* p = new_head->next;
            ListNode* pre = new_head;
            // 处理cur节点, 插入到对应的位置
            while (p != nullptr && p->val < cur->val) {
                p = p->next;
                pre = pre->next;
            }
            pre->next = cur;
            cur->next = p;
            // 继续下一个迭代
            cur = cur_next;
        }
        return new_head->next;
    }
};
```

**Python Code**
```Python

```

## 复杂度

由于需要一次处理每一个元素, 而且对于任意一个元素都需要遍历已经有序的链表一次. 因此, 时间复杂度是`O(n^2)`. 代码运行过程中, 申请了常数个变量, 因此空间复杂度是`O(1)`.

## PangLeetCode

Pang：来源自我家的猫老大叫胖胖，我们不定时给它们讲一些LeetCode算法题目，所以取名PangLeetCode。

大家对题目有任何的想法，随时邮件，或者加微信好友，随时交流。

邮箱: xiaoranone@gmail.com

微信: xiaoran-2 