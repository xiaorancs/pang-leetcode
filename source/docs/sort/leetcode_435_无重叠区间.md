# leetcode 435. 无重叠区间
## 题目先导

> 排序来排序去，数值虽有序，学习无高低。 —— by 胖胖

| 类型 | 难度 | 相关标签&基础知识 | 题目链接 |
| :------: | :--------: | :---: | :------: | 
| 算法 | 中等 | [贪心](#)、[排序](#) | [无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/) | 

## 题目描述

```
给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:
可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

示例 1:
输入: [ [1,2], [2,3], [3,4], [1,3] ]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:
输入: [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

示例 3:
输入: [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

## 解题思路

为了删除更少的区间，我们反向计算，尽可能多的得到不重复的区间。为了得到更多的不重叠的区间，在保持不重复的条件下，我们尽可能选择最靠近左边的区间，让后面可能得到更多的区间。例如示例1:
```
输入: [ [1,2], [1,3], [2,3], [3,4] ]

对于[1,2]和[1,3]这两个重叠的区间，我们必须要选择一个，为了后面有更多的空间，我们选择[1,2]，是因为2之后的区间是[2, +oo]，3之后的区间是[3, +oo]，因此选择[1,2]可以贪心得到更多的区间。

```
我们定义区间`[left, right]`，根据right进行升序排序。


## 难点分析
如何定义有效的排序方式，对于区间类的题目，一般情况下都是先排序在进行区间比较。排序的比较方式，我们需要找到两个连续的区间`[left, right]`，分别比较使用left和right的排序方式，谁能得到最大的好处。

## 代码
- 代码支持：C++、Python

**C++ Code**
```C++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        // 为了得到更多的区间，我们首先进行排序，排序的比较方式是：定义[left, right]，
        // 根据right升序排序，因为我们尽可能选择最左边的区间，才能得到更多区间
        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){
            return a[1] < b[1];
        });

        int k = 1;
        // 比较每一个区间，第i个区间和上传可以使用区间cur重复，则删除第i个区间。
        int cur = 0;
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] >= intervals[cur][1]) {
                cur = i;
                k ++;
            }
        }
        return intervals.size() - k;
    }
};
```

**Python Code**
```Python

```

## 复杂度
时间复杂度是排序和遍历比较，分别是`O(nlogn)`和`O(n)`，最后的时间复杂度是`O(nlogn)`。中间计算过程中，只使用了常数个变量空间，因此空间复杂度是`O(1)`。

## PangLeetCode

Pang：来源自我家的猫老大叫胖胖，我们不定时给它们讲一些LeetCode算法题目，所以取名PangLeetCode。

大家对题目有任何的想法，随时邮件，或者加微信好友，随时交流。

邮箱: xiaoranone@gmail.com

微信: xiaoran-2 