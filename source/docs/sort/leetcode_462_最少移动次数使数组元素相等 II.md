# leetcode 462. 最少移动次数使数组元素相等 II

## 题目先导

> 排序来排序去，数值虽有序，学习无高低。 —— by 胖胖

| 类型 | 难度 | 相关标签&基础知识 | 题目链接 |
| :------: | :--------: | :---: | :------: | 
| 算法 | 中等 | 数组、[排序](#) | [最少移动次数使数组元素相等 II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/) | 

## 题目描述

```
给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。

例如:
输入:
[1,2,3]
输出:
2

说明：
只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： 

[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
```

## 解题思路
首先需要明确一个问题，把所有数值转化成整个数字的中位数，可以得到最少的移动次数。

```
假设最终的值是x，对于数组nums，最少的移动次数是：
|nums[0]-x| + |nums[1]-x| + ... + |nums[n-1]-x|

经典的数学问题，当 x 为这个 N 个数的中位数时，可以使得距离最小。

具体地，若 N 为奇数，则 x 必须为这 N 个数中的唯一中位数；

若 N 为偶数，中间的两个数为 p 和 q，中位数为 (p + q) / 2，此时 x 只要是区间 [p, q] 中的任意一个数即可。

```

## 难点分析

难点1. 是如何证明所有数字都转为中位数，才能得到最少的移动距离。

难点2. 如何快速的找到数组的中位数，排序的时间复杂度是`O(nlogn)`；快速选择中位数算法时间复杂度
难点2. 如何快速的找到数组的中位数，排序的时间复杂度是`O(nlogn)`；快速选择中位数算法渐进的时间复杂度是`O(n)`。

## 代码
- 代码支持：C++、Python

**C++ Code**
```C++
class Solution {
public:
    int minMoves2(vector<int>& nums) {
        // 方案1. 先排序找到中位数
        int val = 0;
        sort(nums.begin(), nums.end());
        if (nums.size() % 2 == 1) {
            val = nums[nums.size() / 2];
        } else {
            val = (nums[nums.size() / 2 - 1] + nums[nums.size() / 2 - 1]) / 2;
        }
        int ans = 0;
        for (int num : nums) {
            ans += abs(val - num);
        }
        return ans;

        // 方案2. 使用快速选择方案找到中位数

    }
};
```

**Python Code**
```Python

```

## 复杂度
方案1、排序的时间复杂度是`O(nlogn)`，根据中位数计算最少移动次数的时间复杂度是`O(n)`，总的时间复杂度是`O(nlogn)`。空间复杂度是`O(1)`。

方案2、找到中位数的渐进意义上的时间复杂度是`O(n)`，空间复杂度是`O(logn)`，主要是递归调用的空间占用。


## PangLeetCode

Pang：来源自我家的猫老大叫胖胖，我们不定时给它们讲一些LeetCode算法题目，所以取名PangLeetCode。

大家对题目有任何的想法，随时邮件，或者加微信好友，随时交流。

邮箱: xiaoranone@gmail.com

微信: xiaoran-2 